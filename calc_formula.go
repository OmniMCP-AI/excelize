// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"fmt"
	"strings"
)

// CalcFormulaValue calculates a formula value without modifying the cell permanently.
// This is a lightweight, read-only operation that doesn't trigger cache clearing.
//
// Unlike SetCellFormula + CalcCellValue, this method:
//   - Does NOT clear calculation cache
//   - Does NOT modify calc chain
//   - Does NOT persist the formula to the file
//   - Only temporarily sets the formula in memory for calculation
//
// The syntax of the function is:
//
//	CalcFormulaValue(sheet, cell, formula, opts...)
//
// Parameters:
//   - sheet: worksheet name
//   - cell: cell address (e.g., "A1")
//   - formula: formula to calculate (without leading "=")
//   - opts: optional calculation options
//
// Example:
//
//	// Preview formula result without saving to file
//	result, err := f.CalcFormulaValue("Sheet1", "A1", "SUM(B1:B10)")
//	if err != nil {
//	    fmt.Println(err)
//	}
//	fmt.Printf("Result: %s\n", result)
//
// Use cases:
//   - Preview formula results before committing
//   - Validate formula syntax without modifying the file
//   - Calculate temporary/derived values
//   - What-if analysis scenarios
func (f *File) CalcFormulaValue(sheet, cell, formula string, opts ...Options) (string, error) {
	ws, err := f.workSheetReader(sheet)
	if err != nil {
		return "", err
	}

	// Prepare cell (ensures row/col exist in XML structure)
	c, _, _, err := ws.prepareCell(cell)
	if err != nil {
		return "", err
	}

	// Save original formula state (if any)
	var originalFormula *xlsxF
	var hadFormula bool

	if c.F != nil {
		hadFormula = true
		// Deep copy to preserve original
		originalFormula = &xlsxF{
			Content: c.F.Content,
			T:       c.F.T,
			Ref:     c.F.Ref,
			Si:      c.F.Si,
			Bx:      c.F.Bx,
			Ca:      c.F.Ca,
			Del1:    c.F.Del1,
			Del2:    c.F.Del2,
			Dt2D:    c.F.Dt2D,
			Dtr:     c.F.Dtr,
			R1:      c.F.R1,
			R2:      c.F.R2,
		}
	}

	// Temporarily set formula IN MEMORY ONLY (no cache clearing!)
	if c.F == nil {
		c.F = &xlsxF{Content: formula}
	} else {
		c.F.Content = formula
	}

	// Calculate the result using the temporary formula
	result, calcErr := f.CalcCellValue(sheet, cell, opts...)

	// Restore original formula state
	if !hadFormula {
		// Cell didn't have a formula before, remove temporary one
		c.F = nil
	} else {
		// Restore original formula
		c.F = originalFormula
	}

	// Clear cache for this cell only to prevent stale results
	// This ensures subsequent calls with different formulas work correctly
	ref := fmt.Sprintf("%s!%s", sheet, cell)
	f.calcCache.Delete(ref)

	return result, calcErr
}

// CalcFormulasValues calculates multiple formulas in batch without modifying cells.
// This is the batch version of CalcFormulaValue for improved performance.
//
// The syntax of the function is:
//
//	CalcFormulasValues(sheet, formulas, opts...)
//
// Parameters:
//   - sheet: worksheet name
//   - formulas: map of cell addresses to formulas (without leading "=")
//   - opts: optional calculation options
//
// Returns:
//   - map[string]string: map of cell addresses to calculated results
//   - error: calculation error if any (partial results still returned)
//
// Example:
//
//	formulas := map[string]string{
//	    "A1": "SUM(B1:B10)",
//	    "A2": "AVERAGE(B1:B10)",
//	    "A3": "MAX(B1:B10)",
//	}
//	results, err := f.CalcFormulasValues("Sheet1", formulas)
//	if err != nil {
//	    fmt.Printf("Some formulas failed: %v\n", err)
//	}
//	for cell, result := range results {
//	    fmt.Printf("%s = %s\n", cell, result)
//	}
func (f *File) CalcFormulasValues(sheet string, formulas map[string]string, opts ...Options) (map[string]string, error) {
	if len(formulas) == 0 {
		return make(map[string]string), nil
	}

	ws, err := f.workSheetReader(sheet)
	if err != nil {
		return nil, err
	}

	results := make(map[string]string, len(formulas))
	var errors []error

	// Save original formulas for all cells
	originalFormulas := make(map[string]*xlsxF, len(formulas))
	hadFormula := make(map[string]bool, len(formulas))

	// Prepare all cells and save their original state
	for cell := range formulas {
		c, _, _, err := ws.prepareCell(cell)
		if err != nil {
			errors = append(errors, fmt.Errorf("failed to prepare %s: %w", cell, err))
			continue
		}

		if c.F != nil {
			hadFormula[cell] = true
			// Deep copy original formula
			originalFormulas[cell] = &xlsxF{
				Content: c.F.Content,
				T:       c.F.T,
				Ref:     c.F.Ref,
				Si:      c.F.Si,
				Bx:      c.F.Bx,
				Ca:      c.F.Ca,
				Del1:    c.F.Del1,
				Del2:    c.F.Del2,
				Dt2D:    c.F.Dt2D,
				Dtr:     c.F.Dtr,
				R1:      c.F.R1,
				R2:      c.F.R2,
			}
		}
	}

	// Set all temporary formulas
	for cell, formula := range formulas {
		c, _, _, err := ws.prepareCell(cell)
		if err != nil {
			continue // Already recorded error above
		}

		if c.F == nil {
			c.F = &xlsxF{Content: formula}
		} else {
			c.F.Content = formula
		}
	}

	// Calculate all formulas
	for cell := range formulas {
		result, err := f.CalcCellValue(sheet, cell, opts...)
		if err != nil {
			errors = append(errors, fmt.Errorf("failed to calculate %s: %w", cell, err))
			continue
		}
		results[cell] = result
	}

	// Restore all original formulas
	for cell := range formulas {
		c, _, _, err := ws.prepareCell(cell)
		if err != nil {
			continue
		}

		if !hadFormula[cell] {
			// Cell didn't have a formula before, remove temporary one
			c.F = nil
		} else {
			// Restore original formula
			c.F = originalFormulas[cell]
		}

		// Clear cache for this cell to prevent stale results
		ref := fmt.Sprintf("%s!%s", sheet, cell)
		f.calcCache.Delete(ref)
	}

	// Return partial results with combined errors if any
	if len(errors) > 0 {
		var sb strings.Builder
		for i, err := range errors {
			if i > 0 {
				sb.WriteString("; ")
			}
			sb.WriteString(err.Error())
		}
		return results, fmt.Errorf("%s", sb.String())
	}

	return results, nil
}
