// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"fmt"
	"strings"
)

// CalcFormulaValue calculates a formula value without modifying the cell permanently.
// This is a lightweight, read-only operation that doesn't trigger cache clearing.
//
// Unlike SetCellFormula + CalcCellValue, this method:
//   - Does NOT clear calculation cache
//   - Does NOT modify calc chain
//   - Does NOT persist the formula to the file
//   - Only temporarily sets the formula in memory for calculation
//
// The syntax of the function is:
//
//	CalcFormulaValue(sheet, cell, formula, opts...)
//
// Parameters:
//   - sheet: worksheet name
//   - cell: cell address (e.g., "A1")
//   - formula: formula to calculate (without leading "=")
//   - opts: optional calculation options
//
// Example:
//
//	// Preview formula result without saving to file
//	result, err := f.CalcFormulaValue("Sheet1", "A1", "SUM(B1:B10)")
//	if err != nil {
//	    fmt.Println(err)
//	}
//	fmt.Printf("Result: %s\n", result)
//
// Use cases:
//   - Preview formula results before committing
//   - Validate formula syntax without modifying the file
//   - Calculate temporary/derived values
//   - What-if analysis scenarios
func (f *File) CalcFormulaValue(sheet, cell, formula string, opts ...Options) (string, error) {
	ws, err := f.workSheetReader(sheet)
	if err != nil {
		return "", err
	}

	// Validate cell reference
	col, row, err := CellNameToCoordinates(cell)
	if err != nil {
		return "", err
	}

	// Try to get existing cell WITHOUT creating it (read-only approach)
	var c *xlsxC
	var isTemporaryCell bool
	var originalRowCount int

	if row <= len(ws.SheetData.Row) {
		rowData := &ws.SheetData.Row[row-1]
		if col <= len(rowData.C) {
			// Cell exists, use it
			c = &rowData.C[col-1]
		}
	}

	// If cell doesn't exist, create a temporary one (in memory only)
	if c == nil {
		isTemporaryCell = true
		c = &xlsxC{R: cell}
		originalRowCount = len(ws.SheetData.Row) // Save original count
	}

	// Save original formula state (if any)
	var originalFormula *xlsxF
	var hadFormula bool

	if c.F != nil {
		hadFormula = true
		// Deep copy to preserve original
		originalFormula = &xlsxF{
			Content: c.F.Content,
			T:       c.F.T,
			Ref:     c.F.Ref,
			Si:      c.F.Si,
			Bx:      c.F.Bx,
			Ca:      c.F.Ca,
			Del1:    c.F.Del1,
			Del2:    c.F.Del2,
			Dt2D:    c.F.Dt2D,
			Dtr:     c.F.Dtr,
			R1:      c.F.R1,
			R2:      c.F.R2,
		}
	}

	// Temporarily set formula IN MEMORY ONLY
	if c.F == nil {
		c.F = &xlsxF{Content: formula}
	} else {
		c.F.Content = formula
	}

	// If using temporary cell, we need to temporarily add it to worksheet for calculation
	if isTemporaryCell {
		// Ensure row exists (create only necessary rows)
		for len(ws.SheetData.Row) < row {
			ws.SheetData.Row = append(ws.SheetData.Row, xlsxRow{
				R: len(ws.SheetData.Row) + 1,
				C: make([]xlsxC, 0),
			})
		}
		rowData := &ws.SheetData.Row[row-1]
		rowData.R = row

		// Add temporary cell to row
		for len(rowData.C) < col {
			cellName, _ := CoordinatesToCellName(len(rowData.C)+1, row)
			rowData.C = append(rowData.C, xlsxC{R: cellName})
		}
		rowData.C[col-1] = *c
	}

	// Calculate the result using the temporary formula
	result, calcErr := f.CalcCellValue(sheet, cell, opts...)

	// Clean up: restore original state
	if isTemporaryCell {
		// Remove all temporarily created rows
		ws.SheetData.Row = ws.SheetData.Row[:originalRowCount]
	} else if !hadFormula {
		// Cell existed but didn't have a formula before, remove temporary one
		c.F = nil
	} else {
		// Restore original formula
		c.F = originalFormula
	}

	// Clear cache for this cell only to prevent stale results
	// Need to clear both raw and formatted cache entries
	ref := fmt.Sprintf("%s!%s", sheet, cell)
	f.calcCache.Delete(fmt.Sprintf("%s!raw=true", ref))
	f.calcCache.Delete(fmt.Sprintf("%s!raw=false", ref))

	return result, calcErr
}

// CalcFormulasValues calculates multiple formulas in batch without modifying cells.
// This is the batch version of CalcFormulaValue for improved performance.
//
// The syntax of the function is:
//
//	CalcFormulasValues(sheet, formulas, opts...)
//
// Parameters:
//   - sheet: worksheet name
//   - formulas: map of cell addresses to formulas (without leading "=")
//   - opts: optional calculation options
//
// Returns:
//   - map[string]string: map of cell addresses to calculated results
//   - error: calculation error if any (partial results still returned)
//
// Example:
//
//	formulas := map[string]string{
//	    "A1": "SUM(B1:B10)",
//	    "A2": "AVERAGE(B1:B10)",
//	    "A3": "MAX(B1:B10)",
//	}
//	results, err := f.CalcFormulasValues("Sheet1", formulas)
//	if err != nil {
//	    fmt.Printf("Some formulas failed: %v\n", err)
//	}
//	for cell, result := range results {
//	    fmt.Printf("%s = %s\n", cell, result)
//	}
func (f *File) CalcFormulasValues(sheet string, formulas map[string]string, opts ...Options) (map[string]string, error) {
	if len(formulas) == 0 {
		return make(map[string]string), nil
	}

	results := make(map[string]string, len(formulas))
	var errors []error

	// Calculate each formula using the optimized CalcFormulaValue
	for cell, formula := range formulas {
		result, err := f.CalcFormulaValue(sheet, cell, formula, opts...)
		if err != nil {
			errors = append(errors, fmt.Errorf("failed to calculate %s: %w", cell, err))
			continue
		}
		results[cell] = result
	}

	// Return partial results with combined errors if any
	if len(errors) > 0 {
		var sb strings.Builder
		for i, err := range errors {
			if i > 0 {
				sb.WriteString("; ")
			}
			sb.WriteString(err.Error())
		}
		return results, fmt.Errorf("%s", sb.String())
	}

	return results, nil
}
