// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.

// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"fmt"
	"strings"

	"github.com/xuri/excelize/v2/duckdb"
)

// CalculationEngine defines the interface for pluggable calculation engines.
// This allows switching between the native Excel formula engine and DuckDB-based engine.
type CalculationEngine interface {
	// SupportsFormula checks if a formula can be handled by this engine.
	SupportsFormula(formula string) bool

	// CalcCellValue calculates a single cell formula.
	CalcCellValue(sheet, cell, formula string) (string, error)

	// CalcCellValues calculates multiple cell formulas efficiently.
	CalcCellValues(sheet string, cells []string, formulas map[string]string) (map[string]string, error)

	// LoadSheetData loads sheet data into the engine.
	LoadSheetData(sheet string, headers []string, data [][]interface{}) error

	// IsSheetLoaded checks if a sheet has been loaded.
	IsSheetLoaded(sheet string) bool

	// ClearCache clears all cached results.
	ClearCache()

	// Close releases resources.
	Close() error
}

// DuckDBEngine wraps the duckdb.Calculator to implement CalculationEngine.
type DuckDBEngine struct {
	calculator *duckdb.Calculator
}

// SetCalculationEngine sets the calculation engine for this workbook.
// Supported engine types:
//   - "native" or "": Use the built-in Excel formula engine (default)
//   - "duckdb": Use the DuckDB-based high-performance engine
//   - "auto": Automatically select based on file size and formula count
//
// Example:
//
//	f, _ := excelize.OpenFile("large_file.xlsx")
//	defer f.Close()
//
//	// Enable DuckDB for large-scale calculations
//	f.SetCalculationEngine("duckdb")
//
//	// Now CalcCellValue will use DuckDB when possible
//	result, _ := f.CalcCellValue("Sheet1", "A1")
func (f *File) SetCalculationEngine(engineType string) error {
	f.mu.Lock()
	defer f.mu.Unlock()

	switch strings.ToLower(engineType) {
	case "duckdb":
		calc, err := duckdb.NewCalculator()
		if err != nil {
			return fmt.Errorf("failed to create DuckDB calculator: %w", err)
		}
		f.calcEngine = &DuckDBEngine{calculator: calc}

	case "auto":
		// Auto-detect based on workbook characteristics
		// Use DuckDB if any sheet has >10K cells or >1K formulas
		shouldUseDuckDB := false
		for _, sheetName := range f.GetSheetList() {
			ws, err := f.workSheetReader(sheetName)
			if err != nil {
				continue
			}

			// Estimate cell count
			cellCount := 0
			formulaCount := 0
			for _, row := range ws.SheetData.Row {
				for _, cell := range row.C {
					cellCount++
					if cell.F != nil && cell.F.Content != "" {
						formulaCount++
					}
				}
			}

			if cellCount > 10000 || formulaCount > 1000 {
				shouldUseDuckDB = true
				break
			}
		}

		if shouldUseDuckDB {
			calc, err := duckdb.NewCalculator()
			if err != nil {
				return fmt.Errorf("failed to create DuckDB calculator: %w", err)
			}
			f.calcEngine = &DuckDBEngine{calculator: calc}
		}

	case "native", "":
		// Close existing DuckDB engine if any
		if f.calcEngine != nil {
			f.calcEngine.Close()
			f.calcEngine = nil
		}

	default:
		return fmt.Errorf("unknown calculation engine: %s", engineType)
	}

	return nil
}

// GetCalculationEngine returns the currently active calculation engine name.
func (f *File) GetCalculationEngine() string {
	f.mu.Lock()
	defer f.mu.Unlock()

	if f.calcEngine != nil {
		if _, ok := f.calcEngine.(*DuckDBEngine); ok {
			return "duckdb"
		}
	}
	return "native"
}

// LoadSheetForDuckDB loads a sheet's data into the DuckDB engine.
// This is required before using DuckDB for formula calculations on that sheet.
func (f *File) LoadSheetForDuckDB(sheet string) error {
	// First, check preconditions with lock
	f.mu.Lock()
	if f.calcEngine == nil {
		f.mu.Unlock()
		return fmt.Errorf("DuckDB engine not enabled, call SetCalculationEngine(\"duckdb\") first")
	}

	duckEngine, ok := f.calcEngine.(*DuckDBEngine)
	if !ok {
		f.mu.Unlock()
		return fmt.Errorf("calculation engine is not DuckDB")
	}

	// Check if already loaded
	if duckEngine.calculator.GetEngine().IsInitialized() {
		if f.calcEngine.IsSheetLoaded(sheet) {
			f.mu.Unlock()
			return nil // Already loaded
		}
	}
	f.mu.Unlock()

	// Extract cell references first (with lock released)
	type cellInfo struct {
		ref string
		col int
	}
	type rowInfo struct {
		cells []cellInfo
	}

	f.mu.Lock()
	ws, err := f.workSheetReader(sheet)
	if err != nil {
		f.mu.Unlock()
		return err
	}

	// Collect cell references
	rows := make([]rowInfo, 0, len(ws.SheetData.Row))
	maxCol := 0
	for _, row := range ws.SheetData.Row {
		ri := rowInfo{cells: make([]cellInfo, 0, len(row.C))}
		for _, cell := range row.C {
			col, _, _ := CellNameToCoordinates(cell.R)
			ri.cells = append(ri.cells, cellInfo{ref: cell.R, col: col})
			if col > maxCol {
				maxCol = col
			}
		}
		rows = append(rows, ri)
	}
	f.mu.Unlock()

	// Now get cell values without holding the main lock
	headers := make([]string, maxCol)
	for i := 0; i < maxCol; i++ {
		headers[i] = fmt.Sprintf("col%d", i+1)
	}

	data := make([][]interface{}, 0, len(rows))
	for rowIdx, ri := range rows {
		rowData := make([]interface{}, maxCol)

		for _, ci := range ri.cells {
			// Get cell value (this will acquire its own lock safely)
			value, _ := f.GetCellValue(sheet, ci.ref)
			if ci.col > 0 && ci.col <= maxCol {
				rowData[ci.col-1] = value
			}
		}

		// First row might be headers
		if rowIdx == 0 && len(data) == 0 {
			// Check if first row looks like headers (non-numeric strings)
			allStrings := true
			for _, v := range rowData {
				if v == nil {
					continue
				}
				if _, ok := v.(string); !ok {
					allStrings = false
					break
				}
			}

			if allStrings {
				for i, v := range rowData {
					if s, ok := v.(string); ok && s != "" {
						headers[i] = s
					}
				}
				continue // Skip header row in data
			}
		}

		data = append(data, rowData)
	}

	return duckEngine.LoadSheetData(sheet, headers, data)
}

// CalcCellValueWithDuckDB calculates a cell formula using DuckDB.
// This is a convenience method that ensures the sheet is loaded and uses DuckDB.
func (f *File) CalcCellValueWithDuckDB(sheet, cell string) (string, error) {
	// Ensure DuckDB is enabled
	if f.calcEngine == nil {
		if err := f.SetCalculationEngine("duckdb"); err != nil {
			return "", err
		}
	}

	// Ensure sheet is loaded
	if err := f.LoadSheetForDuckDB(sheet); err != nil {
		return "", err
	}

	// Get formula
	formula, err := f.GetCellFormula(sheet, cell)
	if err != nil {
		return "", err
	}

	if formula == "" {
		// No formula, just get the value
		return f.GetCellValue(sheet, cell)
	}

	// Calculate using DuckDB
	return f.calcEngine.CalcCellValue(sheet, cell, formula)
}

// CalcCellValuesWithDuckDB calculates multiple cell formulas using DuckDB.
// This is more efficient than calling CalcCellValue multiple times.
func (f *File) CalcCellValuesWithDuckDB(sheet string, cells []string) (map[string]string, error) {
	// Ensure DuckDB is enabled
	if f.calcEngine == nil {
		if err := f.SetCalculationEngine("duckdb"); err != nil {
			return nil, err
		}
	}

	// Ensure sheet is loaded
	if err := f.LoadSheetForDuckDB(sheet); err != nil {
		return nil, err
	}

	// Get formulas for all cells
	formulas := make(map[string]string, len(cells))
	for _, cell := range cells {
		formula, _ := f.GetCellFormula(sheet, cell)
		if formula != "" {
			formulas[cell] = formula
		}
	}

	// Calculate using DuckDB
	return f.calcEngine.CalcCellValues(sheet, cells, formulas)
}

// PrecomputeSUMIFS creates a pre-computed cache for SUMIFS calculations.
// This significantly speeds up batch SUMIFS calculations by pre-computing
// all possible aggregations.
func (f *File) PrecomputeSUMIFS(sheet, sumCol string, criteriaCols []string) error {
	f.mu.Lock()
	defer f.mu.Unlock()

	if f.calcEngine == nil {
		return fmt.Errorf("DuckDB engine not enabled")
	}

	duckEngine, ok := f.calcEngine.(*DuckDBEngine)
	if !ok {
		return fmt.Errorf("calculation engine is not DuckDB")
	}

	config := duckdb.AggregationCacheConfig{
		SumCol:       sumCol,
		CriteriaCols: criteriaCols,
		IncludeSum:   true,
		IncludeCount: true,
		IncludeAvg:   true,
	}

	return duckEngine.calculator.GetEngine().PrecomputeAggregations(sheet, config)
}

// DuckDBEngine implementation of CalculationEngine

// SupportsFormula checks if a formula can be handled by DuckDB.
func (e *DuckDBEngine) SupportsFormula(formula string) bool {
	if e.calculator == nil {
		return false
	}
	return e.calculator.SupportsFormula(formula)
}

// CalcCellValue calculates a single cell formula using DuckDB.
func (e *DuckDBEngine) CalcCellValue(sheet, cell, formula string) (string, error) {
	if e.calculator == nil {
		return "", fmt.Errorf("DuckDB calculator not initialized")
	}
	return e.calculator.CalcCellValue(sheet, cell, formula)
}

// CalcCellValues calculates multiple cell formulas using DuckDB.
func (e *DuckDBEngine) CalcCellValues(sheet string, cells []string, formulas map[string]string) (map[string]string, error) {
	if e.calculator == nil {
		return nil, fmt.Errorf("DuckDB calculator not initialized")
	}
	return e.calculator.CalcCellValues(sheet, cells, formulas)
}

// LoadSheetData loads sheet data into the DuckDB engine.
func (e *DuckDBEngine) LoadSheetData(sheet string, headers []string, data [][]interface{}) error {
	if e.calculator == nil {
		return fmt.Errorf("DuckDB calculator not initialized")
	}
	return e.calculator.LoadSheetData(sheet, headers, data)
}

// IsSheetLoaded checks if a sheet has been loaded into DuckDB.
func (e *DuckDBEngine) IsSheetLoaded(sheet string) bool {
	if e.calculator == nil {
		return false
	}
	return e.calculator.IsSheetLoaded(sheet)
}

// ClearCache clears all cached results.
func (e *DuckDBEngine) ClearCache() {
	if e.calculator != nil {
		e.calculator.ClearCache()
	}
}

// Close releases DuckDB resources.
func (e *DuckDBEngine) Close() error {
	if e.calculator != nil {
		return e.calculator.Close()
	}
	return nil
}
