// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"bytes"
	"encoding/xml"
	"io"
	"strconv"
)

// calcChainReader provides a function to get the pointer to the structure
// after deserialization of xl/calcChain.xml.
func (f *File) calcChainReader() (*xlsxCalcChain, error) {
	if f.CalcChain == nil {
		f.CalcChain = new(xlsxCalcChain)
		if err := f.xmlNewDecoder(bytes.NewReader(namespaceStrictToTransitional(f.readXML(defaultXMLPathCalcChain)))).
			Decode(f.CalcChain); err != nil && err != io.EOF {
			return f.CalcChain, err
		}
	}
	return f.CalcChain, nil
}

// calcChainWriter provides a function to save xl/calcChain.xml after
// serialize structure.
func (f *File) calcChainWriter() {
	if f.CalcChain != nil && f.CalcChain.C != nil {
		output, _ := xml.Marshal(f.CalcChain)
		f.saveFileList(defaultXMLPathCalcChain, output)
	}
}

// deleteCalcChain provides a function to remove cell reference on the
// calculation chain.
func (f *File) deleteCalcChain(index int, cell string) error {
	calc, err := f.calcChainReader()
	if err != nil {
		return err
	}
	if calc != nil {
		calc.C = xlsxCalcChainCollection(calc.C).Filter(func(c xlsxCalcChainC) bool {
			return !((c.I == index && c.R == cell) || (c.I == index && cell == "") || (c.I == 0 && c.R == cell))
		})
	}
	if len(calc.C) == 0 {
		f.CalcChain = nil
		f.Pkg.Delete(defaultXMLPathCalcChain)
		content, err := f.contentTypesReader()
		if err != nil {
			return err
		}
		content.mu.Lock()
		defer content.mu.Unlock()
		for k, v := range content.Overrides {
			if v.PartName == "/xl/calcChain.xml" {
				content.Overrides = append(content.Overrides[:k], content.Overrides[k+1:]...)
			}
		}
	}
	return err
}

type xlsxCalcChainCollection []xlsxCalcChainC

// Filter provides a function to filter calculation chain.
func (c xlsxCalcChainCollection) Filter(fn func(v xlsxCalcChainC) bool) []xlsxCalcChainC {
	var results []xlsxCalcChainC
	for _, v := range c {
		if fn(v) {
			results = append(results, v)
		}
	}
	return results
}

// volatileDepsReader provides a function to get the pointer to the structure
// after deserialization of xl/volatileDependencies.xml.
func (f *File) volatileDepsReader() (*xlsxVolTypes, error) {
	if f.VolatileDeps == nil {
		volatileDeps, ok := f.Pkg.Load(defaultXMLPathVolatileDeps)
		if !ok {
			return f.VolatileDeps, nil
		}
		f.VolatileDeps = new(xlsxVolTypes)
		if err := f.xmlNewDecoder(bytes.NewReader(namespaceStrictToTransitional(volatileDeps.([]byte)))).
			Decode(f.VolatileDeps); err != nil && err != io.EOF {
			return f.VolatileDeps, err
		}
	}
	return f.VolatileDeps, nil
}

// volatileDepsWriter provides a function to save xl/volatileDependencies.xml
// after serialize structure.
func (f *File) volatileDepsWriter() {
	if f.VolatileDeps != nil {
		output, _ := xml.Marshal(f.VolatileDeps)
		f.saveFileList(defaultXMLPathVolatileDeps, output)
	}
}

// deleteVolTopicRef provides a function to remove cell reference on the
// volatile dependencies topic.
func (vt *xlsxVolTypes) deleteVolTopicRef(i1, i2, i3, i4 int) {
	for i := range vt.VolType[i1].Main[i2].Tp[i3].Tr {
		if i == i4 {
			vt.VolType[i1].Main[i2].Tp[i3].Tr = append(vt.VolType[i1].Main[i2].Tp[i3].Tr[:i], vt.VolType[i1].Main[i2].Tp[i3].Tr[i+1:]...)
		}
	}
}

// UpdateCellCache updates the formula cache for a specific cell and all cells
// that depend on it. This function uses the calculation chain (calcChain.xml)
// to determine which cells need their cache cleared. When a cell's cache is
// cleared, Excel will recalculate the formula when the workbook is opened.
//
// This is more efficient than UpdateLinkedValue() when you only need to update
// a single cell, as it only clears the cache for the affected cell and its
// dependents, rather than all formula cells in the workbook.
//
// Note: This function requires that the workbook has a valid calcChain.xml file.
// If the calcChain doesn't exist or the cell is not found in it, the function
// will fall back to clearing only the specified cell's cache.
//
// Example:
//
//	f.SetCellValue("Sheet1", "A1", 100)
//	err := f.UpdateCellCache("Sheet1", "A1")
func (f *File) UpdateCellCache(sheet, cell string) error {
	// Get sheet ID (1-based, matches calcChain)
	sheetID := f.getSheetID(sheet)
	if sheetID == -1 {
		return ErrSheetNotExist{SheetName: sheet}
	}

	// Read calcChain
	calcChain, err := f.calcChainReader()
	if err != nil {
		return err
	}

	// If calcChain doesn't exist or is empty, just clear the specified cell
	if calcChain == nil || len(calcChain.C) == 0 {
		return f.clearCellFormulaCache(sheet, cell)
	}

	// Find the cell in calcChain
	cellIndex := f.findCellInCalcChain(calcChain, sheetID, cell)

	// If cell not found in calcChain, just clear the specified cell
	if cellIndex == -1 {
		return f.clearCellFormulaCache(sheet, cell)
	}

	// Clear cache for the cell and all subsequent cells in the same sheet
	// (subsequent cells may depend on this cell)
	return f.clearCachesFromIndex(calcChain, sheetID, cellIndex)
}

// findCellInCalcChain finds the index of a cell in the calculation chain.
// Returns -1 if the cell is not found.
func (f *File) findCellInCalcChain(calcChain *xlsxCalcChain, sheetIndex int, cell string) int {
	for i, c := range calcChain.C {
		// Match by sheet index and cell reference
		if c.I == sheetIndex && c.R == cell {
			return i
		}
		// If I is 0, it means same sheet as previous cell
		if i > 0 && c.I == 0 && c.R == cell {
			// Check if previous cell's sheet matches
			prevSheetIndex := calcChain.C[i-1].I
			if prevSheetIndex == sheetIndex {
				return i
			}
		}
	}
	return -1
}

// clearCachesFromIndex clears the cache for all cells starting from the given
// index in the calculation chain that belong to the same sheet.
func (f *File) clearCachesFromIndex(calcChain *xlsxCalcChain, sheetID, startIndex int) error {
	// Get sheet name from sheetID
	sheetName := f.GetSheetMap()[sheetID]
	if sheetName == "" {
		return ErrSheetNotExist{SheetName: ""}
	}

	// Get worksheet
	ws, err := f.workSheetReader(sheetName)
	if err != nil {
		return err
	}

	// Track current sheet ID (for handling I=0 case)
	currentSheetID := sheetID

	// Clear cache for cells starting from startIndex
	for i := startIndex; i < len(calcChain.C); i++ {
		c := calcChain.C[i]

		// Update current sheet ID if specified
		if c.I != 0 {
			currentSheetID = c.I
		}

		// Only clear cache for cells in the same sheet
		if currentSheetID != sheetID {
			continue
		}

		// Clear the cell's cache
		if err := f.clearCellFormulaCacheInWorksheet(ws, c.R); err != nil {
			return err
		}
	}

	return nil
}

// clearCellFormulaCache clears the formula cache for a single cell.
func (f *File) clearCellFormulaCache(sheet, cell string) error {
	ws, err := f.workSheetReader(sheet)
	if err != nil {
		return err
	}
	return f.clearCellFormulaCacheInWorksheet(ws, cell)
}

// clearCellFormulaCacheInWorksheet clears the formula cache value for a cell in a worksheet.
func (f *File) clearCellFormulaCacheInWorksheet(ws *xlsxWorksheet, cell string) error {
	_, row, err := CellNameToCoordinates(cell)
	if err != nil {
		return err
	}

	// Find the cell in the worksheet
	for i := range ws.SheetData.Row {
		if ws.SheetData.Row[i].R == row {
			for j := range ws.SheetData.Row[i].C {
				if ws.SheetData.Row[i].C[j].R == cell {
					// Clear cache if cell has a formula
					if ws.SheetData.Row[i].C[j].F != nil {
						ws.SheetData.Row[i].C[j].V = ""
						ws.SheetData.Row[i].C[j].T = ""
					}
					return nil
				}
			}
		}
	}

	// Cell not found or doesn't have a formula - not an error
	return nil
}

// UpdateCellAndRecalculate updates a cell value and immediately recalculates all
// dependent formula cells, updating their cached values. This is useful when you
// need the formula results immediately without waiting for Excel to recalculate.
//
// Unlike UpdateCellCache which only clears the cache (letting Excel recalculate
// on open), this function performs the calculation immediately and stores the
// results back into the cell cache.
//
// The function uses the calculation chain (calcChain.xml) to determine which
// cells depend on the updated cell and recalculates them in order.
//
// Note: This function requires that the workbook has a valid calcChain.xml file.
// If the calcChain doesn't exist, it will only recalculate the specified cell.
//
// Example:
//
//	// Set A1 = 10, B1 = A1*2, C1 = B1+5
//	f.SetCellValue("Sheet1", "A1", 10)
//	f.SetCellFormula("Sheet1", "B1", "=A1*2")
//	f.SetCellFormula("Sheet1", "C1", "=B1+5")
//
//	// Update A1 to 20 and recalculate B1 and C1 immediately
//	f.SetCellValue("Sheet1", "A1", 20)
//	err := f.UpdateCellAndRecalculate("Sheet1", "A1")
//	// Now B1 cache = 40, C1 cache = 45
func (f *File) UpdateCellAndRecalculate(sheet, cell string) error {
	// Get sheet ID (1-based, matches calcChain)
	sheetID := f.getSheetID(sheet)
	if sheetID == -1 {
		return ErrSheetNotExist{SheetName: sheet}
	}

	// Read calcChain
	calcChain, err := f.calcChainReader()
	if err != nil {
		return err
	}

	// If calcChain doesn't exist or is empty, just recalculate the specified cell if it has a formula
	if calcChain == nil || len(calcChain.C) == 0 {
		return f.recalculateCell(sheet, cell)
	}

	// Find the cell in calcChain
	cellIndex := f.findCellInCalcChain(calcChain, sheetID, cell)

	// If cell is in calcChain, recalculate from that point onward
	if cellIndex != -1 {
		return f.recalculateFromIndex(calcChain, sheetID, cellIndex)
	}

	// Cell not in calcChain - it's a value cell or not tracked
	// Recalculate ALL formulas in this sheet (they might depend on this cell)
	return f.recalculateAllInSheet(calcChain, sheetID)
}

// recalculateFromIndex recalculates all cells starting from the given index
// in the calculation chain that belong to the same sheet.
func (f *File) recalculateFromIndex(calcChain *xlsxCalcChain, sheetID, startIndex int) error {
	// Get sheet name from sheetID
	sheetName := f.GetSheetMap()[sheetID]
	if sheetName == "" {
		return ErrSheetNotExist{SheetName: ""}
	}

	// Track current sheet ID (for handling I=0 case)
	currentSheetID := sheetID

	// Recalculate cells starting from startIndex
	for i := startIndex; i < len(calcChain.C); i++ {
		c := calcChain.C[i]

		// Update current sheet ID if specified
		if c.I != 0 {
			currentSheetID = c.I
		}

		// Only recalculate cells in the same sheet
		if currentSheetID != sheetID {
			continue
		}

		// Recalculate the cell
		if err := f.recalculateCell(sheetName, c.R); err != nil {
			return err
		}
	}

	return nil
}

// recalculateAllInSheet recalculates all cells in the calcChain for a given sheet.
func (f *File) recalculateAllInSheet(calcChain *xlsxCalcChain, sheetID int) error {
	// Get sheet name from sheetID
	sheetName := f.GetSheetMap()[sheetID]
	if sheetName == "" {
		return ErrSheetNotExist{SheetName: ""}
	}

	// Track current sheet ID (for handling I=0 case)
	currentSheetID := -1

	// Recalculate all cells in the sheet
	for i := range calcChain.C {
		c := calcChain.C[i]

		// Update current sheet ID if specified
		if c.I != 0 {
			currentSheetID = c.I
		}

		// Only recalculate cells in the target sheet
		if currentSheetID != sheetID {
			continue
		}

		// Recalculate the cell
		if err := f.recalculateCell(sheetName, c.R); err != nil {
			return err
		}
	}

	return nil
}

// recalculateCell recalculates a single formula cell and updates its cache.
func (f *File) recalculateCell(sheet, cell string) error {
	ws, err := f.workSheetReader(sheet)
	if err != nil {
		return err
	}

	// Check if the cell has a formula
	col, row, err := CellNameToCoordinates(cell)
	if err != nil {
		return err
	}

	var cellRef *xlsxC
	for i := range ws.SheetData.Row {
		if ws.SheetData.Row[i].R == row {
			for j := range ws.SheetData.Row[i].C {
				if ws.SheetData.Row[i].C[j].R == cell {
					cellRef = &ws.SheetData.Row[i].C[j]
					break
				}
			}
			break
		}
	}

	// If cell doesn't exist or doesn't have a formula, nothing to do
	if cellRef == nil || cellRef.F == nil {
		return nil
	}

	// Calculate the formula value
	result, err := f.CalcCellValue(sheet, cell)
	if err != nil {
		// If calculation fails, clear the cache instead of returning error
		cellRef.V = ""
		cellRef.T = ""
		return nil
	}

	// Update the cache with the calculated value
	return f.updateCellCache(ws, col, row, cell, result)
}

// updateCellCache updates the cached value for a cell in the worksheet.
func (f *File) updateCellCache(ws *xlsxWorksheet, col, row int, cell, value string) error {
	// Find the cell in the worksheet
	for i := range ws.SheetData.Row {
		if ws.SheetData.Row[i].R == row {
			for j := range ws.SheetData.Row[i].C {
				if ws.SheetData.Row[i].C[j].R == cell {
					// Update cache value
					ws.SheetData.Row[i].C[j].V = value
					// Determine type based on value
					if value == "" {
						ws.SheetData.Row[i].C[j].T = ""
					} else if value == "TRUE" || value == "FALSE" {
						ws.SheetData.Row[i].C[j].T = "b"
					} else {
						// Try to parse as number
						if _, err := strconv.ParseFloat(value, 64); err == nil {
							ws.SheetData.Row[i].C[j].T = "n"
						} else {
							ws.SheetData.Row[i].C[j].T = "str"
						}
					}
					return nil
				}
			}
		}
	}

	// Cell not found - should not happen if CalcCellValue succeeded
	return nil
}
