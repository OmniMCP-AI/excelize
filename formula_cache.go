// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

// UpdateFormulaCache calculates all formulas in the workbook and updates their
// cached values. This is useful when you create a file with formulas and want
// to ensure the values are available when reading the file later without
// depending on Excel to calculate them.
//
// Example:
//
//	f := excelize.NewFile()
//	f.SetCellValue("Sheet1", "A1", 10)
//	f.SetCellValue("Sheet1", "A2", 20)
//	f.SetCellFormula("Sheet1", "A3", "A1+A2")
//
//	// Calculate all formulas and update cache
//	if err := f.UpdateFormulaCache(); err != nil {
//	    log.Fatal(err)
//	}
//
//	f.SaveAs("output.xlsx")
//
//	// Later when you open this file:
//	f2, _ := excelize.OpenFile("output.xlsx")
//	value, _ := f2.GetCellValue("Sheet1", "A3")
//	// value = "30" (cached value is available)
func (f *File) UpdateFormulaCache() error {
	f.mu.Lock()
	var sheetNames []string
	for sheetName := range f.sheetMap {
		sheetNames = append(sheetNames, sheetName)
	}
	f.mu.Unlock()

	for _, sheetName := range sheetNames {
		if err := f.UpdateSheetFormulaCache(sheetName); err != nil {
			return err
		}
	}
	return nil
}

// UpdateSheetFormulaCache calculates all formulas in the specified worksheet
// and updates their cached values.
//
// Example:
//
//	f := excelize.NewFile()
//	f.SetCellValue("Sheet1", "A1", 10)
//	f.SetCellFormula("Sheet1", "A2", "A1*2")
//
//	// Calculate formulas only in Sheet1
//	if err := f.UpdateSheetFormulaCache("Sheet1"); err != nil {
//	    log.Fatal(err)
//	}
func (f *File) UpdateSheetFormulaCache(sheet string) error {
	// Phase 1: Collect all formula cells (with locks)
	type formulaCell struct {
		rowIdx int
		colIdx int
		cell   string
	}

	var formulas []formulaCell

	f.mu.Lock()
	ws, err := f.workSheetReader(sheet)
	f.mu.Unlock()
	if err != nil {
		return err
	}

	ws.mu.Lock()
	for rowIdx := range ws.SheetData.Row {
		for colIdx := range ws.SheetData.Row[rowIdx].C {
			cell := &ws.SheetData.Row[rowIdx].C[colIdx]
			if cell.F != nil && cell.F.Content != "" {
				formulas = append(formulas, formulaCell{
					rowIdx: rowIdx,
					colIdx: colIdx,
					cell:   cell.R,
				})
			}
		}
	}
	ws.mu.Unlock()

	if len(formulas) == 0 {
		return nil
	}

	// Phase 2: Calculate formulas using batch API (WITHOUT locks to avoid deadlock)
	// Collect all cell references
	cells := make([]string, len(formulas))
	for i, fc := range formulas {
		cells[i] = fc.cell
	}

	// Batch calculate all formulas with RawCellValue=true
	// This ensures we cache the raw calculated value (like Excel does)
	// rather than the formatted value, so styling can be applied on read
	results, err := f.CalcCellValues(sheet, cells, Options{RawCellValue: true})
	if err != nil {
		// CalcCellValues returns partial results even on error
		// Continue to update the cached values for successful calculations
		// but return the error at the end
	}

	// Phase 3: Update cached values (with locks)
	ws.mu.Lock()
	defer ws.mu.Unlock()

	for rowIdx := range ws.SheetData.Row {
		for colIdx := range ws.SheetData.Row[rowIdx].C {
			cell := &ws.SheetData.Row[rowIdx].C[colIdx]
			if value, ok := results[cell.R]; ok {
				cell.V = value
				// Clear the cell type attribute so it will be determined by the value
				// This allows formatting to be applied correctly when reading
				// (SetCellFormula sets c.T="str", but after caching we want normal type handling)
				cell.T = ""
			}
		}
	}

	// Return error if any calculation failed
	return err
}
